<!doctype html>
<html lang="fr-fr">
  <head>
    <title>Création d&#39;un cron avec SNS // Tech blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.66.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://example.org/css/main.min.d59a293bff4cb6f7fcce92a5c9833de7107393f80e4efe3110eea46955464842.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Création d&#39;un cron avec SNS"/>
<meta name="twitter:description" content="Ou comment complètement détourner l’usage du service Amazon SNS.
Mon besoin est simple : pouvoir exécuter du code toutes les 30s. Cette tâche commencera et s’arrêtera en fonction d’actions utilisateur. En java j’aurais simplement utilisé Quartz, mais là mon code est en PHP et hébergé sur Beanstalk d’Amazon.
Je n’ai pas trouvé de service simple à utiliser sur AWS pour faire ça. On trouve bien un peu de doc pour le faire avec Data Pipeline mais c’est loin d’être trivial."/>

    <meta property="og:title" content="Création d&#39;un cron avec SNS" />
<meta property="og:description" content="Ou comment complètement détourner l’usage du service Amazon SNS.
Mon besoin est simple : pouvoir exécuter du code toutes les 30s. Cette tâche commencera et s’arrêtera en fonction d’actions utilisateur. En java j’aurais simplement utilisé Quartz, mais là mon code est en PHP et hébergé sur Beanstalk d’Amazon.
Je n’ai pas trouvé de service simple à utiliser sur AWS pour faire ça. On trouve bien un peu de doc pour le faire avec Data Pipeline mais c’est loin d’être trivial." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/2014/02/05/creation-dun-cron-avec-sns/" />
<meta property="article:published_time" content="2014-02-05T09:32:50+00:00" />
<meta property="article:modified_time" content="2014-02-05T09:32:50+00:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="http://example.org/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>Tech blog</h1>
      <p>Vieux blog technique</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/sliard" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Création d&#39;un cron avec SNS</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 5, 2014
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="http://example.org/tags/aws/">AWS</a></div></div>
    </header>
    <div class="post-content">
      <p>Ou comment complètement détourner l’usage du service Amazon SNS.</p>
<p>Mon besoin est simple : pouvoir exécuter du code toutes les 30s. Cette tâche commencera et s’arrêtera en fonction d’actions utilisateur. En java j’aurais simplement utilisé Quartz, mais là mon code est en PHP et hébergé sur Beanstalk d’Amazon.</p>
<p>Je n’ai pas trouvé de service simple à utiliser sur AWS pour faire ça. On trouve bien un peu de doc pour le faire avec Data Pipeline mais c’est loin d’être trivial. Après beaucoup d’hésitation j’ai décidé d’utiliser le service SNS.</p>
<p>Pour faire simple, SNS est un service de diffusion de message multi-canal. (doc complète <a href="http://docs.aws.amazon.com/sns/latest/dg/welcome.html" title="SNS">ici</a> )</p>
<p><img src="/images/uploads/2014/02/sns-how-works.png" alt="SNS"></p>
<p>Par contre il n’est pas fait pour envoyer un message périodiquement. Avec SNS on ne peut pas non plus dire “envoie ce message dans 30s”, le message est distribué de suite. Donc pour mon cas d’usage ce n’est pas vraiment l’idéal. J’aurais tellement aimé pouvoir dans mon code avoir un consommateur de message qui une fois le traitement fini s’envoie un nouveau message à lui même mais pour dans 30s.</p>
<p>Malheureusement ce n’est pas aussi simple et c’est lorsque j’ai regardé les politiques de retry pour les abonnements en http que j’ai trouvé une solution à mon problème. En effet, dans le cas d’un message envoyé sur un consommateur HTTP, si la requête retourne un code d’erreur (type 5xx) alors le message n’est pas considéré comme lu et va être représenté au même consomateur suivant une politique de retry configurable (toutes les infos <a href="http://docs.aws.amazon.com/sns/latest/dg/DeliveryPolicies.html">sur la doc</a>).</p>
<p><img src="/images/uploads/2014/02/sns-delivery-policy-defaults.png" alt="SNS"></p>
<p>Et là on voit bien se profiler une tâche périodique</p>
<p>C’est, je vous l’accorde, assez border line. Mais ça a le mérite d’être simple et de fonctionner. Le seul inconvénient c’est que le nombre de retry est limité à 99. Donc dans mon cas mon cron s’arrêtait après 50 minutes. Il n’y a pas d’information dans le message envoyé par SNS du nombre de retry, par contre il y a sa date d’émission. Dans mon consommateur, j’ai donc codé qu’après 2 minutes  j’envoyais un nouveau message et retournais un code HTTP 200 pour consommer le message et arrêter les retry sur celui-ci. Au début j’avais mis 10 minutes, mais je ne sais pas pourquoi, même avec un code 200 les retry continuaient toujours sur le message. Avec 2 minutes (et donc moins de retry) aucun problème.</p>
<p>Cela donne cette architecture :</p>
<p><img src="/images/uploads/2014/02/SNS.png" alt="SNS"></p>
<p>Et un diagramme de séquence pour bien comprendre le déroulement  :</p>
<p><img src="/images/uploads/2014/02/Untitled-4.png" alt="SNS"></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Oui retourner une erreur 500 alors que le traitement s’est bien passé n’est pas très orthodoxe, Mais le système fonctionne bien, je peux voir sur la console SNS le nombre de Topic ouverts et donc le nombre de cron en cours d’exécution. C’est assez pratique. Si vous avez d’autres solutions je suis preneur ! (des services comme <a href="http://www.setcronjob.com">setcronjob</a> ou même <a href="http://www.easycron.com/?r=15708">easycron</a> sont trop limités au niveau requête par jour)</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
